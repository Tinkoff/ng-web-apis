"use strict";exports.id=224,exports.ids=[224],exports.modules={88224:module=>{module.exports="# ![logo](https://raw.githubusercontent.com/Tinkoff/ng-web-apis/main/libs/universal/logo.svg) Angular Universal fallbacks\n\n[![npm version](https://img.shields.io/npm/v/@ng-web-apis/universal.svg)](https://npmjs.com/package/@ng-web-apis/universal)\n[![npm bundle size](https://img.shields.io/bundlephobia/minzip/@ng-web-apis/universal)](https://bundlephobia.com/result?p=@ng-web-apis/universal)\n[![Coveralls github](https://img.shields.io/coveralls/github/ng-web-apis/universal)](https://coveralls.io/github/ng-web-apis/universal?branch=master)\n\nA set of fallbacks to seamlessly use [@ng-web-apis/common](https://github.com/tinkoff/ng-web-apis/tree/main/libs/common)\nin [Angular Universal](https://github.com/angular/universal) apps. These packages have synced versions down to minor.\n\n## How to use\n\nAdd constants imported from this package to providers of your `ServerAppModule`. Typically, you can also use these mocks\nfor tests. Idea of this package is \u2014 you shouldn't have to mock DOM on the server side or test `isPlatformBrowser` all\nthe time. Instead, you leverage Angular DI system to abstract from implementation. When possible, this package will\nprovide the same functionality on the server side as you have in browser. In other cases you will get type-safe mocks\nand you can at least be sure you will not have `cannot read propery of null` or `undefined is not a function` errors in\nSSR.\n\n## Mocks\n\nAdd following line to your `server.ts` to mock native classes used in other @ng-web-apis packages:\n\n```js\nimport '@ng-web-apis/universal/mocks';\n```\n\n> It is recommended to keep the import statement at the top of your `server.ts` file\n\n## Tokens\n\nYou can provide tokens from this package into your `app.server.module.ts` to have type safe mocks for global objects on\nserver side with `UniversalModule`:\n\n```ts\n@NgModule({\n  imports: [\n    AppBrowserModule,\n    ServerModule,\n    UniversalModule, // <-- add this\n  ],\n  bootstrap: [AppComponent],\n})\nexport class AppServerModule {}\n```\n\nAlternatively, if you have a standalone app that is initialized using the bootstrapApplication function, you can import\n`UNIVERSAL_PROVIDERS` in the following manner:\n\n```ts\nconst serverConfig: ApplicationConfig = {\n  providers: [\n    provideServerRendering(),\n    UNIVERSAL_PROVIDERS, // <-- add this\n  ],\n};\n\nconst config = mergeApplicationConfig(appConfig, serverConfig);\nconst bootstrap = () => bootstrapApplication(AppComponent, config);\n```\n\n## Special cases\n\nWhen you use plain SSR without prerender you can retrieve some of the information from requests. Use the following\nhelpers to harvest that info:\n\n**server.ts:**\n\n```typescript\nimport {provideLocation, provideUserAgent} from '@ng-web-apis/universal';\n\n// ...\n\napp.get('/**/*', (req: Request, res: Response) => {\n  res.render('../dist/index', {\n    req,\n    res,\n    providers: [provideLocation(req), provideUserAgent(req)],\n  });\n});\n```\n"}};